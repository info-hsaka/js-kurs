"use strict";(self.webpackChunkjs_kurs=self.webpackChunkjs_kurs||[]).push([[909],{4232:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});var r=i(4848),s=i(8453);const l={sidebar_position:4},a="Scopes",t={id:"part-two/scopes",title:"Scopes",description:"In der Programmierung gibt es an sich nicht besonders viele verschiedene Konstrukte - mit Variablen, Conditionals, Operatoren und Loops haben wir bereits einen Gro\xdfteil kennengelernt. Trotzdem lassen sich mit so wenigen Konstrukten beliebig komplexe Probleme l\xf6sen. Es gibt mehrere Mechanismen, die das erm\xf6glichen. Einer davon sind Scopes.",source:"@site/docs/part-two/scopes.md",sourceDirName:"part-two",slug:"/part-two/scopes",permalink:"/js-kurs/docs/part-two/scopes",draft:!1,unlisted:!1,editUrl:"https://github.com/info-hsaka/js-kurs/docs/part-two/scopes.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Loops",permalink:"/js-kurs/docs/part-two/loops"},next:{title:"Functions",permalink:"/js-kurs/docs/part-two/functions"}},o={},d=[{value:"Lokale Variablen",id:"lokale-variablen",level:2},{value:"Es wird komplexer",id:"es-wird-komplexer",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"scopes",children:"Scopes"}),"\n",(0,r.jsx)(n.p,{children:"In der Programmierung gibt es an sich nicht besonders viele verschiedene Konstrukte - mit Variablen, Conditionals, Operatoren und Loops haben wir bereits einen Gro\xdfteil kennengelernt. Trotzdem lassen sich mit so wenigen Konstrukten beliebig komplexe Probleme l\xf6sen. Es gibt mehrere Mechanismen, die das erm\xf6glichen. Einer davon sind Scopes."}),"\n",(0,r.jsx)(n.h2,{id:"lokale-variablen",children:"Lokale Variablen"}),"\n",(0,r.jsxs)(n.p,{children:["Immer wenn man in Javascript eine geschwungene Klammer ",(0,r.jsx)(n.code,{children:"{"})," aufmacht \xf6ffnet man gleichzeitig einen neuen Scope. Die n\xe4chste geschlossene geschwungene Klammer ",(0,r.jsx)(n.code,{children:"}"})," schlie\xdft diesen Scope wieder."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"if (5 > 2) {\n    // Ich bin in einem Scope\n}\n\nwhile (true) {\n    // Ich bin auch in einem Scope (in einem anderen als oben)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Ein Scope ist ein Bereich des Codes, in dem neu angelegte Variablen leben. Das bedeutet, dass wenn innerhalb eines Scopes eine Variable angelegt wird, sie am Ende des Scopes wieder verworfen wird. Ein simples Beispiel:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const a = 10\n\nif (a > 8) {\n    // b wird im lokalen if Scope angelegt und ist nur hier exitent\n    const b = a + 5\n    console.log(b)\n    // b h\xf6rt hier auf zu existieren\n}\n\n// console.log(b) w\xfcrde hier einen Fehler erzeugen, da b hier nicht mehr existiert\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Dasselbe gilt auch innerhalb von ",(0,r.jsx)(n.code,{children:"else"})," oder ",(0,r.jsx)(n.code,{children:"while"})," Bl\xf6cken - eben immer innerhalb von ",(0,r.jsx)(n.code,{children:"{}"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Das bedeutet, dass wir innerhalb von ",(0,r.jsx)(n.code,{children:"{}"})," eigene kleine Variablen f\xfcr Zwischenergebnisse und lokale L\xf6sungswege anlegen k\xf6nnen und klar markieren, dass diese nur lokal innerhalb dieses Scopes relevant sind und au\xdferhalb davon nicht beachtet werden m\xfcssen (und auch nicht k\xf6nnen)."]}),"\n",(0,r.jsx)(n.h2,{id:"es-wird-komplexer",children:"Es wird komplexer"}),"\n",(0,r.jsxs)(n.p,{children:["Inwiefern erlauben Scopes es uns, komplexere Probleme mit simplen Konstrukten zu l\xf6sen? Mit einem Verst\xe4ndnis von Scopes k\xf6nnen wir verschiedene Konstrukte (wie ",(0,r.jsx)(n.code,{children:"while"})," und ",(0,r.jsx)(n.code,{children:"if"}),') ineinander verschachteln und die daf\xfcr ben\xf6tigten Variablen in m\xf6glichst "engen" (also m\xf6glichst kurz lebenden Scopes) anlegen um die \xdcbersicht zu behalten. Ein Beispiel:']}),"\n",(0,r.jsxs)(n.admonition,{title:"Erinnerung Primzahlen",type:"info",children:[(0,r.jsxs)(n.p,{children:["Das Programm unten findet alle Primzahlen bis zu einer Zahl ",(0,r.jsx)(n.code,{children:"target"})," (f\xfcr ",(0,r.jsx)(n.code,{children:"target"})," = 6 sollten wir also 2, 3, 5 erhalten)."]}),(0,r.jsxs)(n.p,{children:["Zur Erinnerung: Eine Primzahl ist eine Zahl, die nur durch 1 und durch sich selbst teilbar ist. Um herauszufinden, ob eine beliebige ganze Zahl ",(0,r.jsx)(n.code,{children:"n"})," prim ist reicht es, alle Zahlen unter ",(0,r.jsx)(n.code,{children:"n"})," durchzuprobieren. Wenn eine davon ein Teiler von ",(0,r.jsx)(n.code,{children:"n"})," ist, dann ist ",(0,r.jsx)(n.code,{children:"n"})," keine Primzahl."]}),(0,r.jsx)(n.p,{children:"Diesen Ansatz setzen wir hier um."})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'const target = 20\n\n// Aktueller Kandidat, der prim sein k\xf6nnte\nlet maybePrim = 2\n\n// Wir wollen alle Zahlen bis target pr\xfcfen\nwhile (num <= target) {\n    // Lokale Variable (innerhalb des Scopes) die speichert, ob der aktuelle Kandidat (num) prim ist. Wir fangen mit der Annahme an, dass er prim ist.\n    let isPrim = true\n    // Lokale Variable (innerhalb des Scopes), speichert den aktuellen Kandidat f\xfcr einen Teiler f\xfcr num\n    let maybeTeiler = 2\n\n    // Wir schauen uns alle Zahlen unter num an\n    while (maybeTeiler < num) {\n        // Pr\xfcfen, ob die Zahl ein Teiler von num ist\n        if (num % maybeTeiler == 0) {\n            // Falls ja, ist num nicht prim...\n            isPrim = false\n            // ...und wir k\xf6nnen aufh\xf6ren nach weiteren Teilern zu suchen\n            break\n        }\n\n        // Schaue den n\xe4chsten m\xf6glichen Teiler an\n        maybeTeiler = maybeTeiler + 1\n    }\n\n    // Falls die Zahl prim ist (also kein Teiler gefunden wurde) geben wir sie als Primzahl in der Konsole aus\n    if (isPrim) {\n        console.log("Primzahl:")\n        console.log(num)\n    }\n\n    // Schaue die n\xe4chste m\xf6gliche Primzahl an\n    num = num + 1\n\n    // Hier ist der Scope zu Ende - isPrim und maybeTeiler werden weggeworfen und im n\xe4chsten while-Durchlauf neu angelegt\n}\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"caution",children:(0,r.jsx)(n.p,{children:'Falls du nicht sofort verstehst, warum oder wie dieses Programm genau funktioniert, ist das nicht schlimm. Nimm dir Zeit, lies die Kommentare, kopiere es in deinen Editor und f\xfchre es aus. Wir verwenden hier zum ersten mal ineinander verschachtelte Loops, es kann einen Moment dauern, bis man sich diese vorstellen kann. Im Zweifel hilft es, den Code im Kopf oder auf einem Blatt Papier Zeile f\xfcr Zeile "auszuf\xfchren" wie der Computer.'})}),"\n",(0,r.jsxs)(n.p,{children:["Dieses Programm w\xfcrde auch funktionieren, wenn ",(0,r.jsx)(n.code,{children:"isPrim"})," und ",(0,r.jsx)(n.code,{children:"maybeTeiler"})," au\xdferhalb des ",(0,r.jsx)(n.code,{children:"while"}),'-Loops deklariert und im Loop immer neu beschrieben werden w\xfcrden. Er w\xe4re aber deutlich schwerer zu verstehen - denn diese beiden Variablen sind nur innerhalb der Schleife f\xfcr die Suche nach Teilern relevant, sie "geh\xf6ren" sozusagen zu der Schleife.']})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var r=i(6540);const s={},l=r.createContext(s);function a(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);